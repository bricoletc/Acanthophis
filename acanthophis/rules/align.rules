#######################################################################
#                                NGMap                                #
#######################################################################
rule ngmap:
    input:
        reads=P("reads/runs/{run}~{lib}.fastq.gz"),
        ref=lambda wc: R(config["data_paths"]['references'][wc.ref]["fasta"], keep_local=True),
    output:
        bam=temp(T("alignments/byrun.raw/ngm/{ref}/{run}~{lib}~{sample}.bam")),
    log:
        L("log/ngm/{ref}~{run}~{lib}~{sample}.log")
    resources: **rule_resources(config, "ngmap", time_min=240, mem_mb=16000, cores=8)
    params:
        sensitivity=config["tool_settings"]["ngm"]["sensitivity"],
    conda: "envs/align.yml"
    shell:
        "( ngm"
        "   -q {input.reads}"
        "   --paired --broken-pairs"
        "   -r {input.ref}"
        "   -t {threads}"
        "   --rg-id {wildcards.run}_{wildcards.lib}_{wildcards.sample}"
        "   --rg-sm {wildcards.sample}"
        "   --sensitivity {params.sensitivity}"
        "| samtools view -Suh - >{output.bam}"
        " ) >{log} 2>&1"


#######################################################################
#                               BWAMem                                #
#######################################################################
rule bwaidx:
    input:
        P("{path}")
    output:
        P("{path}.amb"),
        P("{path}.ann"),
        P("{path}.bwt"),
        P("{path}.pac"),
        P("{path}.sa"),
    conda: "envs/align.yml"
    log: L("log/bwaidx/{path}.log")
    resources: **rule_resources(config, "bwaidx", time_min=20, mem_mb=8000)
    shell:
        "bwa index {input} >{log} 2>&1"


rule bwamem:
    input:
        reads=T("reads/runs/{run}~{lib}.fastq.gz"),
        ref=lambda wc: R(config["data_paths"]['references'][wc.ref]["fasta"], keep_local=True),
        bwaidxamb=lambda wc: R(config["data_paths"]['references'][wc.ref]["fasta"]+ ".amb", keep_local=True),
        bwaidxann=lambda wc: R(config["data_paths"]['references'][wc.ref]["fasta"]+ ".ann", keep_local=True),
        bwaidxbwt=lambda wc: R(config["data_paths"]['references'][wc.ref]["fasta"]+ ".bwt", keep_local=True),
        bwaidxpac=lambda wc: R(config["data_paths"]['references'][wc.ref]["fasta"]+ ".pac", keep_local=True),
        bwaidxsa=lambda wc: R(config["data_paths"]['references'][wc.ref]["fasta"]+ ".sa", keep_local=True),
    output:
        bam=temp(T("alignments/byrun.raw/bwa/{ref}/{run}~{lib}~{sample}.bam")),
    log: L("log/bwa/{ref}~{run}~{lib}~{sample}.log")
    resources: **rule_resources(config, "bwamem", time_min=240, mem_gb=10, cores=8)
    conda: "envs/align.yml"
    shell:
        "( bwa mem"
        "   -p" # paired input
        "   -t {threads}"
        "   -R '@RG\\tID:{wildcards.run}_{wildcards.lib}_{wildcards.sample}\\tSM:{wildcards.sample}'"
        "   {input.ref}"
        "   {input.reads}"
        " | samtools view -Suh - >{output.bam}"
        " ) >{log} 2>&1"


#######################################################################
#                     samtools merge/sort/markdup                     #
#######################################################################
rule bam_merge_markdups_sort:
    input:
        bams=lambda wc: T(["alignments/byrun.raw/{aln}/{ref}/{run}~{lib}~{sample}.bam".format(
                            run=r, lib=l, aln=wc.aligner, ref=wc.ref, sample=wc.sample)
	                for r, l in config["SAMP2RUNLIB"][wc.sample]]),
        ref=lambda wc: R(config["data_paths"]['references'][wc.ref]["fasta"], keep_local=True),
    output:
        bam=P("alignments/samples/{aligner}/{ref}/{sample}.bam"),
        bai=P("alignments/samples/{aligner}/{ref}/{sample}.bam.bai"),
    resources: **rule_resources(config, "bam_markdups_sort", time_min=240, mem_gb=8, disk_gb=10, cores=4)
    log: L("log/markdup/{aligner}~{ref}~{sample}.log")
    conda: "envs/align.yml"
    priority: 1 # so the temps get cleaned sooner
    shell:
        "( samtools merge"
        "   -@ {threads}"
        "   -u"
        "   -o /dev/stdout"
        "   {input.bams}"
        " | samtools fixmate "
        "   -m"
        "   -@ {threads}"
        "   -u"
        "   /dev/stdin"
        "   /dev/stdout"
        " | samtools sort"
        "   -T ${{TMPDIR:-/tmp}}/{wildcards.sample}_sort_$RANDOM"
        "   --output-fmt bam,level=0"
        "   -@ {threads}"
        "   -m 1g" # multiplied by {threads} i.e. 4gb
        "   /dev/stdin"
        " | samtools markdup"
        "   -T ${{TMPDIR:-/tmp}}/{wildcards.sample}_markdup_$RANDOM"
        "   -s" # report stats
        "   -@ {threads}"
        "   --output-fmt bam,level=4"
        "   /dev/stdin"
        "   /dev/stdout"
        " | tee {output.bam}"
        " | samtools index - {output.bai}"  # indexing takes bloody ages, we may as well do this on the fly
        " ) > {log} 2>&1"



#######################################################################
#                     Merge samples -> samplesets                     #
#######################################################################

rule mergebam_set:
    input:
        lambda wc: P(expand("alignments/samples/{aligner}/{ref}/{sample}.bam",
                          aligner=wc.aligner, ref=wc.ref, sample=config["SAMPLESETS"][wc.sampleset])),
    output:
        bam=P("alignments/sets/{aligner}~{ref}~{sampleset}.bam"),
        bai=P("alignments/sets/{aligner}~{ref}~{sampleset}.bam.bai"),
    log:
        L("log/mergesetbam/{aligner}~{ref}~{sampleset}.log"),
    resources: **rule_resources(config, "mergebam_set", time_min=2880, mem_gb=16, disk_gb=1000, cores=16)
    conda: "envs/align.yml"
    shell:
        "( samtools merge"
        "   --output-fmt bam,level=8"
        "   -@ {threads}"
        "   -"
        "   {input}"
        " | tee {output.bam}"
        " | samtools index - {output.bai}"  # indexing takes bloody ages, we may as well do this on the fly
        " ) >{log} 2>&1"


#######################################################################
#                              Bam stats                              #
#######################################################################
rule bamstat_sample:
    input:
        P("alignments/samples/{aligner}/{ref}/{sample}.bam"),
    output:
        P("alignments/bamstats/sample/{aligner}~{ref}~{sample}.samtools.stats"),
    log:
        L("log/bamstat_sample/{aligner}~{ref}~{sample}.log")
    resources: **rule_resources(config, "bamstat_sample", time_min=120, mem_gb=4)
    conda: "envs/align.yml"
    shell:
        "(samtools stats -i 5000 -x {input} >{output}) >{log}"

#######################################################################
#                           Unmapped reads                            #
#######################################################################

rule extract_unmapped:
    input:
        P("alignments/samples/{aligner}/{ref}/{sample}.bam"),
    output:
        P("alignments/unmapped_reads/{sample}~{aligner}~{ref}.fastq.gz"),
    log:
        L("log/bamstat_sample/{aligner}~{ref}~{sample}.log")
    resources: **rule_resources(config, "extract_unmapped", time_min=120, mem_gb=1, cores=2)
    conda: "envs/align.yml"
    shell:
        "(samtools fastq -t -i -f4 -c8 -@ {threads} -o {output} {input} ) >{log}"


#######################################################################
#                         Align Target Rules                          #
#######################################################################


rule align_samples:
    input:
        [ P(expand("alignments/samples/{aligner}/{ref}/{sample}.bam",
                 ref=config["samplesets"][ss].get("align", {}).get("references", []),
                 aligner=config["samplesets"][ss].get("align", {}).get("aligners", []),
                 sample=config["SAMPLESETS"][ss]))
          for ss in config["samplesets"]
          if config["samplesets"][ss].get("align", {}) ]

rule unmapped_reads:
    input:
        [ P(expand("alignments/unmapped_reads/{sample}~{aligner}~{ref}.fastq.gz",
                 ref=config["samplesets"][ss].get("align", {}).get("references", []),
                 aligner=config["samplesets"][ss].get("align", {}).get("aligners", []),
                 sample=config["SAMPLESETS"][ss]))
          for ss in config["samplesets"]
          if config["samplesets"][ss].get("align", {}).get("unmapped_reads", False) ]

rule align_samplesets:
    input:
        [ P(expand("alignments/sets/{aligner}~{ref}~{sampleset}.bam",
                 ref=config["samplesets"][ss].get("align", {}).get("references", []),
                 aligner=config["samplesets"][ss].get("align", {}).get("aligners", []),
                 sampleset=ss))
          for ss in config["samplesets"]
          if config["samplesets"][ss].get("align", {}) ]

rule align:
    input:
        rules.align_samples.input,
        rules.align_samplesets.input,
